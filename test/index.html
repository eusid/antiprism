<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>JavaScript Crypto Demo, using JS-RSA and CryptoJS (AES)</title>
  </head>

<script language="JavaScript" type="text/javascript" src="jsbn.js"></script>
<script language="JavaScript" type="text/javascript" src="jsbn2.js"></script>
<script language="JavaScript" type="text/javascript" src="prng4.js"></script>
<script language="JavaScript" type="text/javascript" src="rng.js"></script>
<script language="JavaScript" type="text/javascript" src="rsa.js"></script>
<script language="JavaScript" type="text/javascript" src="rsa2.js"></script>
<script language="JavaScript" type="text/javascript" src="aes.js"></script>
<script language="JavaScript" type="text/javascript" src="CryptJS-core-min.js"></script>
<script language="JavaScript" type="text/javascript" src="scrypt.js"></script>
<script language="JavaScript">
<!--
function hex2a(hex) {
    var str = '';
    for (var i = 0; i < hex.length; i += 2)
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    return str;
}

function parseLatin(string) {
  return CryptoJS.enc.Latin1.parse(string);
}

function utf8_b64enc(string) {
  return CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(string));
}

function utf8_b64dec(string) {
  return CryptoJS.enc.Utf8.stringify(CryptoJS.enc.Base64.parse(string));
}

function decryptAES(cipher, key) {
  cipher = atob(cipher);
  var iv = parseLatin(cipher.substring(0,16));
  var cipher = parseLatin(cipher.substring(16));
  var key = parseLatin(key);
  var decrypted = CryptoJS.AES.decrypt({ciphertext:cipher},key,{iv:iv});
  return CryptoJS.enc.Utf8.stringify(decrypted);
}

function encryptAES(string, key) {
  var key = parseLatin(key);
  var iv = parseLatin(rng_get_string(16));
  var cipher = CryptoJS.AES.encrypt(string, key, { iv: iv });
  return btoa(hex2a(cipher.iv+cipher.ciphertext));
}

function buildAESKey(password) {
  var salt = "i_iz_static_salt";
  var hash = scrypt.crypto_scrypt(scrypt.encode_utf8(password),scrypt.encode_utf8(salt), 16384, 8, 1, 32)
  return String.fromCharCode.apply(null, new Uint8Array(hash));
}

function generateKeypair() {
  var rsa = new RSAKey();
  rsa.generate(2048,"10001");
  var pubkey = {};
  pubkey.n = rsa.n.toString(16);
  pubkey.e = rsa.e.toString(16);
  return {pubkey: pubkey, privkey: rsa.d.toString(16)};
}

function encryptRSA(plain, pubkey) {
  var rsa = new RSAKey();
  rsa.setPublic(pubkey.n, pubkey.e);
  return rsa.encrypt(plain);
}

function decryptRSA(cipher, pubkey, privkey) {
  var rsa = new RSAKey();
  rsa.setPrivate(pubkey.n, pubkey.e, privkey);
  return rsa.decrypt(cipher);
}

function wsDemo(username,password,register) {
  console.log("# # # WS-Login demo # # #");
  // <config>
  //register = false; //
  var user = {name:username, password: buildAESKey(password), conversations:{}};
  var ws = new WebSocket("ws://localhost:8080");
  // </config>

  var msgqueue = [];
  ws.user = user;
  ws.msgqueue = msgqueue;
  ws.decryptmsg = function(msg) {
    if(user.conversations[msg.from])
      console.log("Got msg from "+msg.from+': '+decryptAES(msg.msg, user.conversations[msg.from]));
    else {
      ws.getKey(msg.from);
      return false;
    }
    return true;
  };
  ws.sendMessage = function(username,msg) {
    if(!user.conversations[username])
     return "get key first!";
    ws.sendObject({action:"storeMessage",user:username,msg:encryptAES(msg,user.conversations[username])});
  };
  ws.getKey = function(username) {
    ws.sendObject({action:"conversationKey",user:username});
  };
  ws.sendObject = function(msg) { ws.send(JSON.stringify(msg)); };
  ws.onopen = function() {
    if(register) {
      keypair = generateKeypair();
      keypair.crypt = encryptAES(keypair.privkey, user.password);
      ws.sendObject({action:"register", username:user.name, pubkey:keypair.pubkey, privkey:keypair.crypt});
    }
    else
      ws.sendObject({action:"login","username":user.name});
  }
  ws.onmessage = function(msg) {
    try {
      var response = JSON.parse(msg.data);
    } catch(e) {
      console.log("tried to parse:"+msg.data+", encountered:");
      console.log(e);
    }
    console.log('[debug] received obj:');
    console.log(response);

    if(response.registered !== undefined) { // context: after registration
      if(response.registered)
        ws.sendObject({action:"login","username":user.name});
      else
        console.log("username already taken!");
    }
    else if(response.validationKey) { // context: login
      user.pubkey = response.pubkey;
      var privkey = decryptAES(response.privkey,user.password);
      user.privkey = privkey;
      var validationKey = decryptRSA(response.validationKey, response.pubkey, privkey);
      ws.sendObject({action:"auth","validationKey":utf8_b64enc(validationKey)}); // windemo
    }
    else if(response.convkey !== undefined) { // context: asked for conversationkey
      if(response.convkey == null)
        ws.sendObject({action:"pubkey",user:response.user});
      else
        user.conversations[response.user] = decryptRSA(response.convkey,user.pubkey,user.privkey);
    }
    else if(response.pubkey) { // context: wants to create/encrypt conversationkey
      var conversationkey = rng_get_string(32);
      keys = [];
      keys.push(encryptRSA(conversationkey, user.pubkey));
      keys.push(encryptRSA(conversationkey, response.pubkey));
      user.conversations[response.user] = conversationkey;
      ws.sendObject({action:"initConversation",convkeys:keys,user:response.user});
    }
    else if(response.msg) { // received msg, no clue yet if necessary keys are present
      if(!ws.decryptmsg(response))
        msgqueue.push(response);
    }
  };
  return ws;
}

function demo() {
  /* situation: A and B want to register with the service with passwords "omgpassword" and "wtfrofl" */
  var A = {};
  A.keypair = generateKeypair();
  console.log("generated A's keypair!");
  A.encryptedPrivKey = encryptAES(A.keypair.privkey, buildAESKey("omgpassword"));
  console.log("...and encrypted it!");
  var B = {}
  B.keypair = generateKeypair();
  console.log("generated B's keypair!");
  B.encryptedPrivKey = encryptAES(B.keypair.privkey, buildAESKey("wtfrofl"));
  console.log("...and encrypted it!");



  // what happens next: keypairA.pubkey and base64(A.encryptedPrivKey) get sent to the server (same for B)

  /* login check is as following: server encrypts random string (e.g. "wurstbrot") with stored pubkey
      and sends the encrypted string + encryptedPrivKey back to the client
  */
  var ServerString = encryptRSA("wurstbrot", A.keypair.pubkey);
  var receivedPrivKey = decryptAES(A.encryptedPrivKey, buildAESKey("omgpassword"));
  var decryptedString = decryptRSA(ServerString, A.keypair.pubkey, receivedPrivKey);
  console.log("Decrypted received string to '"+decryptedString+"'");
  // client sent back the correct string, so he obviously has the right pw to decrypt his privkey -> logged in

  /* initiating a conversation:
    1) generate a random conversation-key (AES)
    2) encrypt key with both own & conversationpartner's pubkey(s)
          (since they are logged in, the can obviously decrypt it)
    3) save both encrypted keys for the conversation on the server
  */
  var conversationkey = rng_get_string(32);
  A.convkey = encryptRSA(conversationkey, A.keypair.pubkey);
  B.convkey = encryptRSA(conversationkey, B.keypair.pubkey);

  // sending a message: simple encrypt it with conversationkey and store on server!
  var message = "oh mein gott, das ist derbe secret!";
  var encryptedMessage = encryptAES(message, conversationkey);

  //receiving a message: decrypt the conversationkey first (once per session), then decrypt the message
  conversationkey = decryptRSA(B.convkey, B.keypair.pubkey, B.keypair.privkey);
  var decryptedMessage = decryptAES(encryptedMessage, conversationkey);
  return decryptedMessage;
} 


//-->
</script>

  <body>
    <h1>JavaScript RSA Cryptography Demo</h1>
  </body>
</html>
